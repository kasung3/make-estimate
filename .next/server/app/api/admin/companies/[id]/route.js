"use strict";
(() => {
var exports = {};
exports.id = "app/api/admin/companies/[id]/route";
exports.ids = ["app/api/admin/companies/[id]/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&page=%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&page=%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   originalPathname: () => (/* binding */ originalPathname),
/* harmony export */   patchFetch: () => (/* binding */ patchFetch),
/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   serverHooks: () => (/* binding */ serverHooks),
/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js");
/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/future/route-kind.js");
/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/lib/patch-fetch.js");
/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _home_ubuntu_make_estimate_nextjs_space_app_api_admin_companies_id_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/admin/companies/[id]/route.ts */ "(rsc)/./app/api/admin/companies/[id]/route.ts");




// We inject the nextConfigOutput here so that we can use them in the route
// module.
const nextConfigOutput = ""
const routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({
    definition: {
        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,
        page: "/api/admin/companies/[id]/route",
        pathname: "/api/admin/companies/[id]",
        filename: "route",
        bundlePath: "app/api/admin/companies/[id]/route"
    },
    resolvedPagePath: "/home/ubuntu/make_estimate/nextjs_space/app/api/admin/companies/[id]/route.ts",
    nextConfigOutput,
    userland: _home_ubuntu_make_estimate_nextjs_space_app_api_admin_companies_id_route_ts__WEBPACK_IMPORTED_MODULE_3__
});
// Pull out the exports that we need to expose from the module. This should
// be eliminated when we've moved the other routes to the new format. These
// are used to hook into the route.
const { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;
const originalPathname = "/api/admin/companies/[id]/route";
function patchFetch() {
    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({
        serverHooks,
        staticGenerationAsyncStorage
    });
}


//# sourceMappingURL=app-route.js.map

/***/ }),

/***/ "(rsc)/./app/api/admin/companies/[id]/route.ts":
/*!***********************************************!*\
  !*** ./app/api/admin/companies/[id]/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DELETE: () => (/* binding */ DELETE),
/* harmony export */   GET: () => (/* binding */ GET),
/* harmony export */   PUT: () => (/* binding */ PUT),
/* harmony export */   dynamic: () => (/* binding */ dynamic)
/* harmony export */ });
/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/api/server.js");
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next-auth/index.js");
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_auth_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/auth-options */ "(rsc)/./lib/auth-options.ts");
/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/db */ "(rsc)/./lib/db.ts");
/* harmony import */ var _lib_billing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/billing */ "(rsc)/./lib/billing.ts");
/* harmony import */ var _lib_stripe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/stripe */ "(rsc)/./lib/stripe.ts");






const dynamic = "force-dynamic";
// GET /api/admin/companies/[id] - Get company detail
async function GET(request, { params }) {
    try {
        const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_lib_auth_options__WEBPACK_IMPORTED_MODULE_2__.authOptions);
        if (!session?.user?.email || !(0,_lib_billing__WEBPACK_IMPORTED_MODULE_4__.isPlatformAdmin)(session.user.email)) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 403
            });
        }
        const { id } = await params;
        const company = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.company.findUnique({
            where: {
                id
            },
            include: {
                billing: {
                    include: {
                        invoices: {
                            orderBy: {
                                createdAt: "desc"
                            },
                            take: 10
                        },
                        couponRedemptions: {
                            orderBy: {
                                redeemedAt: "desc"
                            }
                        }
                    }
                },
                memberships: {
                    include: {
                        user: {
                            select: {
                                id: true,
                                email: true,
                                name: true,
                                firstName: true,
                                lastName: true,
                                phone: true,
                                country: true,
                                isBlocked: true,
                                lastLoginAt: true,
                                createdAt: true
                            }
                        }
                    },
                    orderBy: {
                        createdAt: "asc"
                    }
                },
                _count: {
                    select: {
                        boqs: true,
                        customers: true,
                        pdfThemes: true,
                        pdfCoverTemplates: true
                    }
                }
            }
        });
        if (!company) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company not found"
            }, {
                status: 404
            });
        }
        // Get BOQ creation count for current billing period
        const now = new Date();
        const periodStart = company.billing?.currentPeriodStart || new Date(now.getFullYear(), now.getMonth(), 1);
        const boqsThisPeriod = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.boqCreationEvent.count({
            where: {
                companyId: id,
                createdAt: {
                    gte: periodStart
                }
            }
        });
        // Get grants
        const grants = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.companyAccessGrant.findMany({
            where: {
                companyId: id
            },
            orderBy: {
                createdAt: "desc"
            }
        });
        // Transform members with role info
        const members = company.memberships.map((m)=>({
                id: m.user.id,
                email: m.user.email,
                name: m.user.name,
                firstName: m.user.firstName,
                lastName: m.user.lastName,
                fullName: [
                    m.user.firstName,
                    m.user.lastName
                ].filter(Boolean).join(" ") || m.user.name || null,
                phone: m.user.phone,
                country: m.user.country,
                role: m.role,
                isActive: m.isActive,
                isBlocked: m.user.isBlocked,
                lastLoginAt: m.user.lastLoginAt,
                memberSince: m.createdAt
            }));
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            company: {
                id: company.id,
                name: company.name,
                currencySymbol: company.currencySymbol,
                currencyPosition: company.currencyPosition,
                defaultVatPercent: company.defaultVatPercent,
                isBlocked: company.isBlocked,
                blockReason: company.blockReason,
                deletedAt: company.deletedAt,
                createdAt: company.createdAt,
                updatedAt: company.updatedAt
            },
            billing: company.billing,
            members,
            grants,
            usage: {
                boqsThisPeriod,
                totalBoqs: company._count.boqs,
                totalCustomers: company._count.customers,
                boqTemplates: company._count.pdfThemes,
                coverTemplates: company._count.pdfCoverTemplates,
                activeMembersCount: company.memberships.filter((m)=>m.isActive).length
            }
        });
    } catch (error) {
        console.error("Error fetching company detail:", error);
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            error: "Failed to fetch company detail"
        }, {
            status: 500
        });
    }
}
// PUT /api/admin/companies/[id] - Update company (name, etc.)
async function PUT(request, { params }) {
    try {
        const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_lib_auth_options__WEBPACK_IMPORTED_MODULE_2__.authOptions);
        if (!session?.user?.email || !(0,_lib_billing__WEBPACK_IMPORTED_MODULE_4__.isPlatformAdmin)(session.user.email)) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 403
            });
        }
        const { id } = await params;
        const body = await request.json();
        const { name } = body;
        const company = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.company.findUnique({
            where: {
                id
            }
        });
        if (!company) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company not found"
            }, {
                status: 404
            });
        }
        const updateData = {};
        if (name !== undefined && name.trim()) {
            updateData.name = name.trim();
        }
        if (Object.keys(updateData).length === 0) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "No valid fields to update"
            }, {
                status: 400
            });
        }
        const updated = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.company.update({
            where: {
                id
            },
            data: updateData
        });
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            success: true,
            company: updated
        });
    } catch (error) {
        console.error("Error updating company:", error);
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            error: "Failed to update company"
        }, {
            status: 500
        });
    }
}
// DELETE /api/admin/companies/[id] - Soft delete company
async function DELETE(request, { params }) {
    try {
        const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_lib_auth_options__WEBPACK_IMPORTED_MODULE_2__.authOptions);
        if (!session?.user?.email || !(0,_lib_billing__WEBPACK_IMPORTED_MODULE_4__.isPlatformAdmin)(session.user.email)) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 403
            });
        }
        const { id } = await params;
        const company = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.company.findUnique({
            where: {
                id
            },
            include: {
                billing: true
            }
        });
        if (!company) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company not found"
            }, {
                status: 404
            });
        }
        if (company.deletedAt) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company already deleted"
            }, {
                status: 400
            });
        }
        // Cancel Stripe subscription if active
        if (company.billing?.stripeSubscriptionId) {
            try {
                await _lib_stripe__WEBPACK_IMPORTED_MODULE_5__.stripe.subscriptions.cancel(company.billing.stripeSubscriptionId);
                console.log(`Canceled subscription ${company.billing.stripeSubscriptionId} for deleted company ${id}`);
            } catch (stripeError) {
                console.error("Failed to cancel Stripe subscription:", stripeError);
            // Continue with delete even if Stripe cancellation fails
            }
        }
        // Soft delete: set deletedAt and block access
        await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.company.update({
            where: {
                id
            },
            data: {
                deletedAt: new Date(),
                isBlocked: true,
                blockReason: "Company deleted by platform admin"
            }
        });
        // Also deactivate all memberships
        await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.companyMembership.updateMany({
            where: {
                companyId: id
            },
            data: {
                isActive: false
            }
        });
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            success: true,
            message: "Company deleted successfully"
        });
    } catch (error) {
        console.error("Error deleting company:", error);
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            error: "Failed to delete company"
        }, {
            status: 500
        });
    }
}


/***/ }),

/***/ "(rsc)/./lib/auth-options.ts":
/*!*****************************!*\
  !*** ./lib/auth-options.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   authOptions: () => (/* binding */ authOptions)
/* harmony export */ });
/* harmony import */ var next_auth_providers_credentials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth/providers/credentials */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next-auth/providers/credentials.js");
/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bcryptjs */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/bcryptjs/index.js");
/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bcryptjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "(rsc)/./lib/db.ts");



const authOptions = {
    providers: [
        (0,next_auth_providers_credentials__WEBPACK_IMPORTED_MODULE_0__["default"])({
            name: "credentials",
            credentials: {
                email: {
                    label: "Email",
                    type: "email"
                },
                password: {
                    label: "Password",
                    type: "password"
                }
            },
            async authorize (credentials) {
                if (!credentials?.email || !credentials?.password) {
                    return null;
                }
                const user = await _db__WEBPACK_IMPORTED_MODULE_2__.prisma.user.findUnique({
                    where: {
                        email: credentials.email
                    },
                    include: {
                        memberships: {
                            include: {
                                company: true
                            }
                        }
                    }
                });
                if (!user) return null;
                const isValid = await bcryptjs__WEBPACK_IMPORTED_MODULE_1___default().compare(credentials.password, user.password);
                if (!isValid) return null;
                // Update lastLoginAt timestamp
                await _db__WEBPACK_IMPORTED_MODULE_2__.prisma.user.update({
                    where: {
                        id: user.id
                    },
                    data: {
                        lastLoginAt: new Date()
                    }
                }).catch((err)=>console.error("Failed to update lastLoginAt:", err));
                const membership = user?.memberships?.[0];
                return {
                    id: user.id,
                    email: user.email,
                    name: user.name,
                    companyId: membership?.companyId ?? null,
                    companyName: membership?.company?.name ?? null,
                    role: membership?.role ?? "MEMBER"
                };
            }
        })
    ],
    callbacks: {
        async jwt ({ token, user }) {
            if (user) {
                token.id = user.id;
                token.companyId = user.companyId;
                token.companyName = user.companyName;
                token.role = user.role;
            }
            return token;
        },
        async session ({ session, token }) {
            if (session?.user) {
                session.user.id = token.id;
                session.user.companyId = token.companyId;
                session.user.companyName = token.companyName;
                session.user.role = token.role;
            }
            return session;
        }
    },
    pages: {
        signIn: "/login"
    },
    session: {
        strategy: "jwt"
    },
    secret: process.env.NEXTAUTH_SECRET
};


/***/ }),

/***/ "(rsc)/./lib/billing.ts":
/*!************************!*\
  !*** ./lib/billing.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActivePlans: () => (/* binding */ getActivePlans),
/* harmony export */   getCompanyBillingStatus: () => (/* binding */ getCompanyBillingStatus),
/* harmony export */   getOrCreateBilling: () => (/* binding */ getOrCreateBilling),
/* harmony export */   getPlanFromDb: () => (/* binding */ getPlanFromDb),
/* harmony export */   isPlatformAdmin: () => (/* binding */ isPlatformAdmin),
/* harmony export */   recordBoqCreation: () => (/* binding */ recordBoqCreation)
/* harmony export */ });
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ "(rsc)/./lib/db.ts");
/* harmony import */ var _barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,startOfMonth!=!date-fns */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/date-fns/startOfMonth.mjs");
/* harmony import */ var _barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,startOfMonth!=!date-fns */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/date-fns/endOfMonth.mjs");


/**
 * Get plan from database (dynamic pricing)
 */ async function getPlanFromDb(planKey) {
    return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.billingPlan.findUnique({
        where: {
            planKey
        }
    });
}
/**
 * Get all active plans from database
 */ async function getActivePlans() {
    return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.billingPlan.findMany({
        where: {
            active: true
        },
        orderBy: {
            sortOrder: "asc"
        }
    });
}
/**
 * Get billing status for a company
 * Priority order:
 * 1) Blocked user/company => deny access
 * 2) Active Stripe subscription => use that plan
 * 3) Active admin grant (not expired/revoked) => use grant plan
 * 4) Active trial grant (not expired) => use trial plan
 * 5) Free plan (always available)
 */ async function getCompanyBillingStatus(companyId) {
    const now = new Date();
    const [company, billing, activeGrants] = await Promise.all([
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.company.findUnique({
            where: {
                id: companyId
            },
            select: {
                isBlocked: true
            }
        }),
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.findUnique({
            where: {
                companyId
            }
        }),
        // Find all active grants (not revoked, not expired) - we'll pick the best one
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyAccessGrant.findMany({
            where: {
                companyId,
                revokedAt: null,
                OR: [
                    {
                        endsAt: null
                    },
                    {
                        endsAt: {
                            gt: now
                        }
                    }
                ]
            },
            orderBy: {
                createdAt: "desc"
            }
        })
    ]);
    const isBlocked = company?.isBlocked ?? false;
    // Separate admin grants from trial grants (admin_grant takes priority)
    const adminGrant = activeGrants.find((g)=>g.grantType === "admin_grant" || g.grantType === "free_forever");
    const trialGrant = activeGrants.find((g)=>g.grantType === "trial");
    const activeGrant = adminGrant || trialGrant;
    // Helper to compute usage for a period
    async function computeUsage(periodStart, periodEnd) {
        return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.boqCreationEvent.count({
            where: {
                companyId,
                createdAt: {
                    gte: periodStart,
                    lte: periodEnd
                }
            }
        });
    }
    // Helper to get plan details from DB
    async function getPlanDetails(planKey) {
        if (!planKey) return null;
        return getPlanFromDb(planKey);
    }
    // Helper to format active grant for response
    const formatActiveGrant = (grant)=>grant ? {
            id: grant.id,
            grantType: grant.grantType,
            planKey: grant.planKey,
            startsAt: grant.startsAt,
            endsAt: grant.endsAt,
            notes: grant.notes
        } : null;
    // 1) Check for admin override on billing record (free_forever, admin_grant)
    // Also check for admin grant in CompanyAccessGrant table
    const hasAdminGrantFromBilling = billing?.accessOverride === "free_forever" || billing?.accessOverride === "admin_grant";
    const hasAdminGrantFromGrant = !!adminGrant;
    if ((hasAdminGrantFromBilling || hasAdminGrantFromGrant) && !isBlocked) {
        // Use grant plan if available, otherwise fallback to billing override plan
        const overridePlan = adminGrant?.planKey || billing?.overridePlan || "business";
        const plan = await getPlanDetails(overridePlan);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        // For admin grants, use calendar month as the period
        const periodStart = adminGrant?.startsAt || (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        const periodEnd = adminGrant?.endsAt || (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: overridePlan,
            status: "active",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: true,
            hasTrialGrant: false,
            accessOverride: billing?.accessOverride ?? (adminGrant ? "admin_grant" : null),
            trialEndsAt: adminGrant?.endsAt ?? null,
            accessSource: "admin_override",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? true,
            sharingAllowed: plan?.sharingAllowed ?? true,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? false,
            watermarkText: plan?.watermarkText ?? null,
            activeGrant: formatActiveGrant(adminGrant)
        };
    }
    // 2) Check for internal trial grant (from coupon)
    if (trialGrant && !isBlocked) {
        const grantPlan = trialGrant.planKey || "starter";
        const plan = await getPlanDetails(grantPlan);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        // For grants, use grant start as period start, end as period end (or calendar month for free_forever)
        const periodStart = trialGrant.startsAt;
        const periodEnd = trialGrant.endsAt || (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: grantPlan,
            status: "trialing",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: false,
            hasTrialGrant: true,
            accessOverride: null,
            trialEndsAt: trialGrant.endsAt,
            accessSource: "grant",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? true,
            sharingAllowed: plan?.sharingAllowed ?? true,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? false,
            watermarkText: plan?.watermarkText ?? null,
            activeGrant: formatActiveGrant(trialGrant)
        };
    }
    // 3) Check for Free plan (no Stripe subscription required)
    if (billing && billing.planKey === "free" && billing.status === "active" && !isBlocked) {
        const plan = await getPlanDetails("free");
        const periodStart = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        const periodEnd = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: "free",
            status: "active",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: false,
            hasTrialGrant: false,
            accessOverride: null,
            trialEndsAt: null,
            accessSource: "free_plan",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? false,
            sharingAllowed: plan?.sharingAllowed ?? false,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? true,
            watermarkText: plan?.watermarkText ?? "BOQ generated with MakeEstimate.com",
            activeGrant: null
        };
    }
    // 4) Check Stripe subscription
    if (!billing || !billing.planKey || !billing.status) {
        return {
            hasActiveSubscription: false,
            isBlocked,
            planKey: null,
            status: null,
            currentPeriodStart: null,
            currentPeriodEnd: null,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod: 0,
            boqLimit: null,
            canCreateBoq: false,
            hasAdminGrant: false,
            hasTrialGrant: false,
            accessOverride: null,
            trialEndsAt: null,
            accessSource: null,
            boqTemplatesLimit: null,
            coverTemplatesLimit: null,
            logoUploadAllowed: false,
            sharingAllowed: false,
            boqItemsLimit: null,
            watermarkEnabled: false,
            watermarkText: null,
            activeGrant: null
        };
    }
    const plan = await getPlanDetails(billing.planKey);
    const hasActiveSubscription = [
        "active",
        "trialing"
    ].includes(billing.status);
    const boqLimit = plan?.boqLimitPerPeriod ?? null;
    // Determine billing period - use stored dates or fallback to calendar month
    // Handle edge case where start/end are identical or invalid (webhook data issue)
    let periodStart;
    let periodEnd;
    const hasValidPeriod = billing.currentPeriodStart && billing.currentPeriodEnd && billing.currentPeriodEnd.getTime() > billing.currentPeriodStart.getTime();
    if (hasValidPeriod) {
        periodStart = billing.currentPeriodStart;
        periodEnd = billing.currentPeriodEnd;
    } else {
        // Fallback: Use calendar month as billing period
        periodStart = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        periodEnd = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        console.warn(`[Billing] Company ${companyId} has invalid period dates, using calendar month fallback`);
    }
    // Count BOQs created this billing period
    const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
    // Determine if company can create BOQ
    let canCreateBoq = false;
    if (isBlocked) {
        canCreateBoq = false;
    } else if (hasActiveSubscription) {
        canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
    }
    return {
        hasActiveSubscription,
        isBlocked,
        planKey: billing.planKey,
        status: billing.status,
        currentPeriodStart: periodStart,
        currentPeriodEnd: periodEnd,
        cancelAtPeriodEnd: billing.cancelAtPeriodEnd,
        boqsUsedThisPeriod,
        boqLimit,
        canCreateBoq,
        hasAdminGrant: false,
        hasTrialGrant: billing.status === "trialing",
        accessOverride: billing?.accessOverride ?? null,
        trialEndsAt: billing.status === "trialing" ? periodEnd : null,
        accessSource: "subscription",
        boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
        coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
        logoUploadAllowed: plan?.logoUploadAllowed ?? true,
        sharingAllowed: plan?.sharingAllowed ?? true,
        boqItemsLimit: plan?.boqItemsLimit ?? null,
        watermarkEnabled: plan?.watermarkEnabled ?? false,
        watermarkText: plan?.watermarkText ?? null,
        activeGrant: null
    };
}
/**
 * Record a BOQ creation event for quota tracking
 */ async function recordBoqCreation(companyId, boqId) {
    await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.boqCreationEvent.create({
        data: {
            companyId,
            boqId
        }
    });
}
/**
 * Check if user email is a platform admin
 */ function isPlatformAdmin(email) {
    if (!email) return false;
    const adminEmails = process.env.PLATFORM_ADMIN_EMAILS?.split(",").map((e)=>e.trim().toLowerCase()) ?? [];
    return adminEmails.includes(email.toLowerCase());
}
/**
 * Get or create CompanyBilling record
 */ async function getOrCreateBilling(companyId) {
    let billing = await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.findUnique({
        where: {
            companyId
        }
    });
    if (!billing) {
        billing = await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.create({
            data: {
                companyId
            }
        });
    }
    return billing;
}


/***/ }),

/***/ "(rsc)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prisma: () => (/* binding */ prisma)
/* harmony export */ });
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ "@prisma/client");
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _performance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./performance */ "(rsc)/./lib/performance.ts");


const globalForPrisma = globalThis;
/**
 * Connection Pool Configuration for Scale (10k-50k companies)
 * 
 * Recommended DATABASE_URL parameters:
 *   ?connection_limit=20&pool_timeout=30&connect_timeout=10
 * 
 * - connection_limit: Max connections per Prisma instance (default: num_cpus * 2 + 1)
 *   For serverless/edge: use 1-5
 *   For standard servers: use 10-20
 * 
 * - pool_timeout: Seconds to wait for a connection from pool (default: 10)
 * - connect_timeout: Seconds to wait for new connection (default: 5)
 * 
 * For high-scale production:
 * - Consider PgBouncer or Supabase connection pooler
 * - Use transaction pooling mode for short queries
 * - Monitor with: SELECT * FROM pg_stat_activity;
 */ // Create Prisma client with query logging enabled
function createPrismaClient() {
    const isProduction = "development" === "production";
    const client = new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({
        log: isProduction ? [
            {
                level: "error",
                emit: "stdout"
            },
            {
                level: "warn",
                emit: "stdout"
            }
        ] : [
            {
                level: "query",
                emit: "event"
            },
            {
                level: "error",
                emit: "stdout"
            },
            {
                level: "warn",
                emit: "stdout"
            }
        ]
    });
    // Add query event listener for slow query detection (dev + prod with ENABLE_QUERY_LOGGING)
    if (!isProduction || process.env.ENABLE_QUERY_LOGGING === "true") {
        client.$on("query", (e)=>{
            const durationMs = e.duration;
            (0,_performance__WEBPACK_IMPORTED_MODULE_1__.logSlowQuery)({
                query: e.query,
                params: e.params,
                durationMs,
                timestamp: new Date(),
                model: extractModelFromQuery(e.query),
                action: extractActionFromQuery(e.query)
            });
        });
    }
    return client;
}
// Extract model name from SQL query for logging
function extractModelFromQuery(query) {
    const fromMatch = query.match(/FROM\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const insertMatch = query.match(/INSERT\s+INTO\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const updateMatch = query.match(/UPDATE\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const deleteMatch = query.match(/DELETE\s+FROM\s+["']?public["']?\.?["']?(\w+)["']?/i);
    return (fromMatch?.[1] || insertMatch?.[1] || updateMatch?.[1] || deleteMatch?.[1] || "unknown").toLowerCase();
}
// Extract action type from SQL query
function extractActionFromQuery(query) {
    const trimmed = query.trim().toUpperCase();
    if (trimmed.startsWith("SELECT")) return "select";
    if (trimmed.startsWith("INSERT")) return "insert";
    if (trimmed.startsWith("UPDATE")) return "update";
    if (trimmed.startsWith("DELETE")) return "delete";
    if (trimmed.startsWith("BEGIN")) return "transaction";
    if (trimmed.startsWith("COMMIT")) return "commit";
    return "other";
}
// Use singleton pattern to prevent connection storms
// In production, each server instance maintains its own pool
// In development, we reuse across hot reloads
const prisma = globalForPrisma.prisma ?? createPrismaClient();
if (true) {
    globalForPrisma.prisma = prisma;
}


/***/ }),

/***/ "(rsc)/./lib/performance.ts":
/*!****************************!*\
  !*** ./lib/performance.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTimer: () => (/* binding */ createTimer),
/* harmony export */   getRecentMetrics: () => (/* binding */ getRecentMetrics),
/* harmony export */   logError: () => (/* binding */ logError),
/* harmony export */   logRequestMetrics: () => (/* binding */ logRequestMetrics),
/* harmony export */   logSlowQuery: () => (/* binding */ logSlowQuery),
/* harmony export */   withTiming: () => (/* binding */ withTiming)
/* harmony export */ });
/**
 * Performance monitoring and logging utilities
 * For tracking request timing, slow queries, and error tracking
 */ // Threshold for slow query logging (in ms)
const SLOW_QUERY_THRESHOLD = parseInt(process.env.SLOW_QUERY_THRESHOLD || "500", 10);
// In-memory metrics buffer for recent requests (circular buffer)
const MAX_METRICS_BUFFER = 1000;
const requestMetricsBuffer = [];
const slowQueryBuffer = [];
/**
 * Log request metrics
 */ function logRequestMetrics(metrics) {
    // Console log for observability
    const logLevel = metrics.durationMs > 1000 ? "warn" : "info";
    const logData = {
        type: "REQUEST_METRICS",
        ...metrics,
        timestamp: metrics.timestamp.toISOString()
    };
    if (logLevel === "warn") {
        console.warn(`[SLOW_REQUEST] ${metrics.method} ${metrics.endpoint} took ${metrics.durationMs}ms`, JSON.stringify(logData));
    } else if (process.env.VERBOSE_LOGGING === "true") {
        console.log(`[REQUEST] ${metrics.method} ${metrics.endpoint} - ${metrics.durationMs}ms`, JSON.stringify(logData));
    }
    // Add to buffer
    requestMetricsBuffer.push(metrics);
    if (requestMetricsBuffer.length > MAX_METRICS_BUFFER) {
        requestMetricsBuffer.shift();
    }
}
/**
 * Log slow query
 */ function logSlowQuery(metrics) {
    if (metrics.durationMs >= SLOW_QUERY_THRESHOLD) {
        console.warn(`[SLOW_QUERY] ${metrics.model}.${metrics.action} took ${metrics.durationMs}ms`, JSON.stringify({
            type: "SLOW_QUERY",
            ...metrics,
            timestamp: metrics.timestamp.toISOString()
        }));
        slowQueryBuffer.push(metrics);
        if (slowQueryBuffer.length > MAX_METRICS_BUFFER) {
            slowQueryBuffer.shift();
        }
    }
}
/**
 * Log application error with context
 */ function logError(error, context) {
    console.error(`[ERROR] ${context.action || context.endpoint || "Unknown"}`, JSON.stringify({
        type: "APP_ERROR",
        message: error.message,
        stack: error.stack,
        name: error.name,
        ...context,
        timestamp: new Date().toISOString()
    }));
}
/**
 * Timer utility for measuring operation duration
 */ function createTimer() {
    const start = performance.now();
    return {
        elapsed: ()=>Math.round(performance.now() - start)
    };
}
/**
 * Wrap an async function with timing and error tracking
 */ async function withTiming(operation, fn, context) {
    const timer = createTimer();
    try {
        const result = await fn();
        const durationMs = timer.elapsed();
        if (durationMs > 1000) {
            console.warn(`[SLOW_OP] ${operation} took ${durationMs}ms`, context);
        }
        return {
            result,
            durationMs
        };
    } catch (error) {
        logError(error, {
            action: operation,
            ...context
        });
        throw error;
    }
}
/**
 * Get recent metrics for debugging/admin
 */ function getRecentMetrics() {
    return {
        requests: requestMetricsBuffer.slice(-100),
        slowQueries: slowQueryBuffer.slice(-100),
        summary: {
            totalRequests: requestMetricsBuffer.length,
            slowRequests: requestMetricsBuffer.filter((r)=>r.durationMs > 1000).length,
            slowQueries: slowQueryBuffer.length,
            avgRequestTime: requestMetricsBuffer.length > 0 ? Math.round(requestMetricsBuffer.reduce((sum, r)=>sum + r.durationMs, 0) / requestMetricsBuffer.length) : 0
        }
    };
}


/***/ }),

/***/ "(rsc)/./lib/stripe.ts":
/*!***********************!*\
  !*** ./lib/stripe.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PLANS: () => (/* binding */ PLANS),
/* harmony export */   getPlanByPriceId: () => (/* binding */ getPlanByPriceId),
/* harmony export */   mapStripeStatus: () => (/* binding */ mapStripeStatus),
/* harmony export */   stripe: () => (/* binding */ stripe),
/* harmony export */   syncStripeQuantity: () => (/* binding */ syncStripeQuantity)
/* harmony export */ });
/* harmony import */ var stripe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stripe */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/stripe/esm/stripe.esm.node.js");
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./db */ "(rsc)/./lib/db.ts");


if (!process.env.STRIPE_SECRET_KEY) {
    throw new Error("STRIPE_SECRET_KEY is not set");
}
const stripe = new stripe__WEBPACK_IMPORTED_MODULE_0__["default"](process.env.STRIPE_SECRET_KEY);
const PLANS = {
    starter: {
        key: "starter",
        name: "Starter",
        priceId: process.env.STRIPE_STARTER_PRICE_ID,
        price: 19,
        boqLimit: 10,
        description: "10 BOQ creations per month"
    },
    business: {
        key: "business",
        name: "Business",
        priceId: process.env.STRIPE_BUSINESS_PRICE_ID,
        price: 39,
        boqLimit: null,
        description: "Unlimited BOQ creations"
    }
};
function getPlanByPriceId(priceId) {
    return Object.values(PLANS).find((plan)=>plan.priceId === priceId);
}
function mapStripeStatus(status) {
    const statusMap = {
        active: "active",
        trialing: "trialing",
        past_due: "past_due",
        canceled: "canceled",
        incomplete: "incomplete",
        incomplete_expired: "incomplete_expired",
        unpaid: "unpaid",
        paused: "canceled"
    };
    return statusMap[status] || "incomplete";
}
/**
 * Sync Stripe subscription quantity with active member count for per-seat billing.
 * Only updates if the plan has per_seat billing model.
 */ async function syncStripeQuantity(companyId) {
    try {
        // Get company billing info
        const billing = await _db__WEBPACK_IMPORTED_MODULE_1__.prisma.companyBilling.findUnique({
            where: {
                companyId
            }
        });
        if (!billing?.stripeSubscriptionId || !billing?.planKey) {
            console.log(`[Stripe Sync] No subscription for company ${companyId}`);
            return;
        }
        // Check if plan uses per-seat model
        const plan = await _db__WEBPACK_IMPORTED_MODULE_1__.prisma.billingPlan.findUnique({
            where: {
                planKey: billing.planKey
            }
        });
        if (!plan || plan.seatModel !== "per_seat") {
            console.log(`[Stripe Sync] Plan ${billing.planKey} does not use per-seat billing`);
            return;
        }
        // Count active members
        const activeCount = await _db__WEBPACK_IMPORTED_MODULE_1__.prisma.companyMembership.count({
            where: {
                companyId,
                isActive: true
            }
        });
        // Ensure at least 1 seat
        const quantity = Math.max(1, activeCount);
        // Get current subscription
        const subscription = await stripe.subscriptions.retrieve(billing.stripeSubscriptionId);
        if (subscription.status === "canceled" || subscription.status === "incomplete_expired") {
            console.log(`[Stripe Sync] Subscription ${billing.stripeSubscriptionId} is not active`);
            return;
        }
        // Find the subscription item (there should be one)
        const subscriptionItem = subscription.items.data[0];
        if (!subscriptionItem) {
            console.error(`[Stripe Sync] No subscription item found for ${billing.stripeSubscriptionId}`);
            return;
        }
        // Only update if quantity changed
        if (subscriptionItem.quantity !== quantity) {
            await stripe.subscriptionItems.update(subscriptionItem.id, {
                quantity,
                proration_behavior: "create_prorations"
            });
            // Update local record
            await _db__WEBPACK_IMPORTED_MODULE_1__.prisma.companyBilling.update({
                where: {
                    companyId
                },
                data: {
                    seatQuantity: quantity
                }
            });
            console.log(`[Stripe Sync] Updated company ${companyId} quantity from ${subscriptionItem.quantity} to ${quantity}`);
        }
    } catch (error) {
        console.error(`[Stripe Sync] Error syncing quantity for company ${companyId}:`, error);
    // Don't throw - this is a background operation
    }
}


/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/next-auth","vendor-chunks/@babel","vendor-chunks/jose","vendor-chunks/openid-client","vendor-chunks/bcryptjs","vendor-chunks/oauth","vendor-chunks/object-hash","vendor-chunks/preact","vendor-chunks/uuid","vendor-chunks/preact-render-to-string","vendor-chunks/oidc-token-hash","vendor-chunks/@panva","vendor-chunks/date-fns","vendor-chunks/stripe"], () => (__webpack_exec__("(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&page=%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fadmin%2Fcompanies%2F%5Bid%5D%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();