"use strict";
(() => {
var exports = {};
exports.id = "app/api/cover-templates/route";
exports.ids = ["app/api/cover-templates/route"];
exports.modules = {

/***/ "@prisma/client":
/*!*********************************!*\
  !*** external "@prisma/client" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@prisma/client");

/***/ }),

/***/ "../../client/components/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/client/components/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/action-async-storage.external.js");

/***/ }),

/***/ "../../client/components/request-async-storage.external":
/*!********************************************************************************!*\
  !*** external "next/dist/client/components/request-async-storage.external.js" ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/request-async-storage.external.js");

/***/ }),

/***/ "../../client/components/static-generation-async-storage.external":
/*!******************************************************************************************!*\
  !*** external "next/dist/client/components/static-generation-async-storage.external.js" ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/client/components/static-generation-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcover-templates%2Froute&page=%2Fapi%2Fcover-templates%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcover-templates%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcover-templates%2Froute&page=%2Fapi%2Fcover-templates%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcover-templates%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   originalPathname: () => (/* binding */ originalPathname),
/* harmony export */   patchFetch: () => (/* binding */ patchFetch),
/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   serverHooks: () => (/* binding */ serverHooks),
/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js");
/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/future/route-kind.js");
/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/server/lib/patch-fetch.js");
/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _home_ubuntu_make_estimate_nextjs_space_app_api_cover_templates_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/cover-templates/route.ts */ "(rsc)/./app/api/cover-templates/route.ts");




// We inject the nextConfigOutput here so that we can use them in the route
// module.
const nextConfigOutput = ""
const routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({
    definition: {
        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,
        page: "/api/cover-templates/route",
        pathname: "/api/cover-templates",
        filename: "route",
        bundlePath: "app/api/cover-templates/route"
    },
    resolvedPagePath: "/home/ubuntu/make_estimate/nextjs_space/app/api/cover-templates/route.ts",
    nextConfigOutput,
    userland: _home_ubuntu_make_estimate_nextjs_space_app_api_cover_templates_route_ts__WEBPACK_IMPORTED_MODULE_3__
});
// Pull out the exports that we need to expose from the module. This should
// be eliminated when we've moved the other routes to the new format. These
// are used to hook into the route.
const { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;
const originalPathname = "/api/cover-templates/route";
function patchFetch() {
    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({
        serverHooks,
        staticGenerationAsyncStorage
    });
}


//# sourceMappingURL=app-route.js.map

/***/ }),

/***/ "(rsc)/./app/api/cover-templates/route.ts":
/*!******************************************!*\
  !*** ./app/api/cover-templates/route.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GET: () => (/* binding */ GET),
/* harmony export */   POST: () => (/* binding */ POST),
/* harmony export */   dynamic: () => (/* binding */ dynamic)
/* harmony export */ });
/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/api/server.js");
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next-auth/index.js");
/* harmony import */ var next_auth__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_auth_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/auth-options */ "(rsc)/./lib/auth-options.ts");
/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/db */ "(rsc)/./lib/db.ts");
/* harmony import */ var _lib_billing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/billing */ "(rsc)/./lib/billing.ts");
const dynamic = "force-dynamic";





// Default cover template configuration matching current PDF output
const getDefaultCoverConfig = ()=>({
        page: {
            backgroundColor: "#ffffff",
            padding: 40,
            defaultFontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
        },
        elements: [
            {
                id: "project_name",
                type: "project_name",
                enabled: true,
                style: {
                    fontSize: 36,
                    fontWeight: "bold",
                    italic: false,
                    underline: false,
                    color: "#0891b2",
                    align: "center",
                    marginTop: 0,
                    marginBottom: 20
                }
            },
            {
                id: "subtitle",
                type: "subtitle",
                enabled: true,
                text: "Bill of Quantities",
                style: {
                    fontSize: 18,
                    fontWeight: "normal",
                    italic: false,
                    underline: false,
                    color: "#666666",
                    align: "center",
                    marginTop: 0,
                    marginBottom: 10
                }
            },
            {
                id: "prepared_for",
                type: "prepared_for",
                enabled: true,
                style: {
                    fontSize: 18,
                    fontWeight: "normal",
                    italic: false,
                    underline: false,
                    color: "#666666",
                    align: "center",
                    marginTop: 0,
                    marginBottom: 40
                }
            },
            {
                id: "company_name",
                type: "company_name",
                enabled: true,
                style: {
                    fontSize: 16,
                    fontWeight: "normal",
                    italic: false,
                    underline: false,
                    color: "#333333",
                    align: "center",
                    marginTop: 0,
                    marginBottom: 0
                }
            }
        ]
    });
async function GET() {
    try {
        const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_lib_auth_options__WEBPACK_IMPORTED_MODULE_2__.authOptions);
        if (!session?.user) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 401
            });
        }
        const companyId = session.user?.companyId;
        if (!companyId) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company not found"
            }, {
                status: 404
            });
        }
        const templates = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.pdfCoverTemplate.findMany({
            where: {
                companyId
            },
            orderBy: [
                {
                    isDefault: "desc"
                },
                {
                    name: "asc"
                }
            ]
        });
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(templates);
    } catch (error) {
        console.error("Error fetching cover templates:", error);
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            error: "Failed to fetch templates"
        }, {
            status: 500
        });
    }
}
async function POST(request) {
    try {
        const session = await (0,next_auth__WEBPACK_IMPORTED_MODULE_1__.getServerSession)(_lib_auth_options__WEBPACK_IMPORTED_MODULE_2__.authOptions);
        if (!session?.user) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Unauthorized"
            }, {
                status: 401
            });
        }
        const companyId = session.user?.companyId;
        if (!companyId) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Company not found"
            }, {
                status: 404
            });
        }
        // Check billing status and template limits
        const billingStatus = await (0,_lib_billing__WEBPACK_IMPORTED_MODULE_4__.getCompanyBillingStatus)(companyId);
        if (!billingStatus.hasActiveSubscription) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Active subscription required to create cover page templates",
                code: "SUBSCRIPTION_REQUIRED"
            }, {
                status: 403
            });
        }
        // Count existing templates
        const existingTemplates = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.pdfCoverTemplate.count({
            where: {
                companyId
            }
        });
        // Check template limit (null = unlimited)
        if (billingStatus.coverTemplatesLimit !== null && existingTemplates >= billingStatus.coverTemplatesLimit) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: `Cover template limit reached. Your ${billingStatus.planKey} plan allows ${billingStatus.coverTemplatesLimit} templates. Upgrade for more.`,
                code: "TEMPLATE_LIMIT_REACHED",
                limit: billingStatus.coverTemplatesLimit,
                current: existingTemplates,
                planKey: billingStatus.planKey
            }, {
                status: 403
            });
        }
        const body = await request.json();
        const { name, configJson, isDefault } = body;
        if (!name) {
            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
                error: "Name is required"
            }, {
                status: 400
            });
        }
        // If this template is set as default, unset any existing default
        if (isDefault) {
            await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.pdfCoverTemplate.updateMany({
                where: {
                    companyId,
                    isDefault: true
                },
                data: {
                    isDefault: false
                }
            });
        }
        const template = await _lib_db__WEBPACK_IMPORTED_MODULE_3__.prisma.pdfCoverTemplate.create({
            data: {
                companyId,
                name,
                configJson: configJson || getDefaultCoverConfig(),
                isDefault: isDefault ?? false
            }
        });
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(template);
    } catch (error) {
        console.error("Error creating cover template:", error);
        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({
            error: "Failed to create template"
        }, {
            status: 500
        });
    }
}


/***/ }),

/***/ "(rsc)/./lib/auth-options.ts":
/*!*****************************!*\
  !*** ./lib/auth-options.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   authOptions: () => (/* binding */ authOptions)
/* harmony export */ });
/* harmony import */ var next_auth_providers_credentials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next-auth/providers/credentials */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next-auth/providers/credentials.js");
/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bcryptjs */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/bcryptjs/index.js");
/* harmony import */ var bcryptjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bcryptjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./db */ "(rsc)/./lib/db.ts");



const authOptions = {
    providers: [
        (0,next_auth_providers_credentials__WEBPACK_IMPORTED_MODULE_0__["default"])({
            name: "credentials",
            credentials: {
                email: {
                    label: "Email",
                    type: "email"
                },
                password: {
                    label: "Password",
                    type: "password"
                }
            },
            async authorize (credentials) {
                if (!credentials?.email || !credentials?.password) {
                    return null;
                }
                const user = await _db__WEBPACK_IMPORTED_MODULE_2__.prisma.user.findUnique({
                    where: {
                        email: credentials.email
                    },
                    include: {
                        memberships: {
                            include: {
                                company: true
                            }
                        }
                    }
                });
                if (!user) return null;
                const isValid = await bcryptjs__WEBPACK_IMPORTED_MODULE_1___default().compare(credentials.password, user.password);
                if (!isValid) return null;
                // Update lastLoginAt timestamp
                await _db__WEBPACK_IMPORTED_MODULE_2__.prisma.user.update({
                    where: {
                        id: user.id
                    },
                    data: {
                        lastLoginAt: new Date()
                    }
                }).catch((err)=>console.error("Failed to update lastLoginAt:", err));
                const membership = user?.memberships?.[0];
                return {
                    id: user.id,
                    email: user.email,
                    name: user.name,
                    companyId: membership?.companyId ?? null,
                    companyName: membership?.company?.name ?? null,
                    role: membership?.role ?? "MEMBER"
                };
            }
        })
    ],
    callbacks: {
        async jwt ({ token, user }) {
            if (user) {
                token.id = user.id;
                token.companyId = user.companyId;
                token.companyName = user.companyName;
                token.role = user.role;
            }
            return token;
        },
        async session ({ session, token }) {
            if (session?.user) {
                session.user.id = token.id;
                session.user.companyId = token.companyId;
                session.user.companyName = token.companyName;
                session.user.role = token.role;
            }
            return session;
        }
    },
    pages: {
        signIn: "/login"
    },
    session: {
        strategy: "jwt"
    },
    secret: process.env.NEXTAUTH_SECRET
};


/***/ }),

/***/ "(rsc)/./lib/billing.ts":
/*!************************!*\
  !*** ./lib/billing.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getActivePlans: () => (/* binding */ getActivePlans),
/* harmony export */   getCompanyBillingStatus: () => (/* binding */ getCompanyBillingStatus),
/* harmony export */   getOrCreateBilling: () => (/* binding */ getOrCreateBilling),
/* harmony export */   getPlanFromDb: () => (/* binding */ getPlanFromDb),
/* harmony export */   isPlatformAdmin: () => (/* binding */ isPlatformAdmin),
/* harmony export */   recordBoqCreation: () => (/* binding */ recordBoqCreation)
/* harmony export */ });
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ "(rsc)/./lib/db.ts");
/* harmony import */ var _barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,startOfMonth!=!date-fns */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/date-fns/startOfMonth.mjs");
/* harmony import */ var _barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=endOfMonth,startOfMonth!=!date-fns */ "(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/date-fns/endOfMonth.mjs");


/**
 * Get plan from database (dynamic pricing)
 */ async function getPlanFromDb(planKey) {
    return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.billingPlan.findUnique({
        where: {
            planKey
        }
    });
}
/**
 * Get all active plans from database
 */ async function getActivePlans() {
    return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.billingPlan.findMany({
        where: {
            active: true
        },
        orderBy: {
            sortOrder: "asc"
        }
    });
}
/**
 * Get billing status for a company
 * Priority: 1) Check blocked, 2) Check active grant, 3) Check Stripe subscription
 */ async function getCompanyBillingStatus(companyId) {
    const now = new Date();
    const [company, billing, activeGrant] = await Promise.all([
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.company.findUnique({
            where: {
                id: companyId
            },
            select: {
                isBlocked: true
            }
        }),
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.findUnique({
            where: {
                companyId
            }
        }),
        // Find active grant (not revoked, not expired)
        _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyAccessGrant.findFirst({
            where: {
                companyId,
                revokedAt: null,
                OR: [
                    {
                        endsAt: null
                    },
                    {
                        endsAt: {
                            gt: now
                        }
                    }
                ]
            },
            orderBy: {
                createdAt: "desc"
            }
        })
    ]);
    const isBlocked = company?.isBlocked ?? false;
    // Helper to compute usage for a period
    async function computeUsage(periodStart, periodEnd) {
        return _db__WEBPACK_IMPORTED_MODULE_0__.prisma.boqCreationEvent.count({
            where: {
                companyId,
                createdAt: {
                    gte: periodStart,
                    lte: periodEnd
                }
            }
        });
    }
    // Helper to get plan details from DB
    async function getPlanDetails(planKey) {
        if (!planKey) return null;
        return getPlanFromDb(planKey);
    }
    // 1) Check for admin override on billing record (free_forever, admin_grant)
    const hasAdminGrant = billing?.accessOverride === "free_forever" || billing?.accessOverride === "admin_grant";
    if (hasAdminGrant && !isBlocked) {
        const overridePlan = billing?.overridePlan || "business";
        const plan = await getPlanDetails(overridePlan);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        // For admin grants, use calendar month as the period
        const periodStart = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        const periodEnd = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: overridePlan,
            status: "active",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: true,
            hasTrialGrant: false,
            accessOverride: billing?.accessOverride ?? null,
            trialEndsAt: null,
            accessSource: "admin_override",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? true,
            sharingAllowed: plan?.sharingAllowed ?? true,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? false,
            watermarkText: plan?.watermarkText ?? null
        };
    }
    // 2) Check for internal access grant (trial/free_forever from coupon)
    if (activeGrant && !isBlocked) {
        const grantPlan = activeGrant.planKey || "starter";
        const plan = await getPlanDetails(grantPlan);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        // For grants, use grant start as period start, end as period end (or calendar month for free_forever)
        const periodStart = activeGrant.startsAt;
        const periodEnd = activeGrant.endsAt || (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        const isTrialGrant = activeGrant.grantType === "trial";
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: grantPlan,
            status: isTrialGrant ? "trialing" : "active",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: false,
            hasTrialGrant: isTrialGrant,
            accessOverride: null,
            trialEndsAt: isTrialGrant ? activeGrant.endsAt : null,
            accessSource: "grant",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? true,
            sharingAllowed: plan?.sharingAllowed ?? true,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? false,
            watermarkText: plan?.watermarkText ?? null
        };
    }
    // 3) Check for Free plan (no Stripe subscription required)
    if (billing && billing.planKey === "free" && billing.status === "active" && !isBlocked) {
        const plan = await getPlanDetails("free");
        const periodStart = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        const periodEnd = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
        const boqLimit = plan?.boqLimitPerPeriod ?? null;
        const canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
        return {
            hasActiveSubscription: true,
            isBlocked: false,
            planKey: "free",
            status: "active",
            currentPeriodStart: periodStart,
            currentPeriodEnd: periodEnd,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod,
            boqLimit,
            canCreateBoq,
            hasAdminGrant: false,
            hasTrialGrant: false,
            accessOverride: null,
            trialEndsAt: null,
            accessSource: "free_plan",
            boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
            coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
            logoUploadAllowed: plan?.logoUploadAllowed ?? false,
            sharingAllowed: plan?.sharingAllowed ?? false,
            boqItemsLimit: plan?.boqItemsLimit ?? null,
            watermarkEnabled: plan?.watermarkEnabled ?? true,
            watermarkText: plan?.watermarkText ?? "BOQ generated with MakeEstimate.com"
        };
    }
    // 4) Check Stripe subscription
    if (!billing || !billing.planKey || !billing.status) {
        return {
            hasActiveSubscription: false,
            isBlocked,
            planKey: null,
            status: null,
            currentPeriodStart: null,
            currentPeriodEnd: null,
            cancelAtPeriodEnd: false,
            boqsUsedThisPeriod: 0,
            boqLimit: null,
            canCreateBoq: false,
            hasAdminGrant: false,
            hasTrialGrant: false,
            accessOverride: null,
            trialEndsAt: null,
            accessSource: null,
            boqTemplatesLimit: null,
            coverTemplatesLimit: null,
            logoUploadAllowed: false,
            sharingAllowed: false,
            boqItemsLimit: null,
            watermarkEnabled: false,
            watermarkText: null
        };
    }
    const plan = await getPlanDetails(billing.planKey);
    const hasActiveSubscription = [
        "active",
        "trialing"
    ].includes(billing.status);
    const boqLimit = plan?.boqLimitPerPeriod ?? null;
    // Determine billing period - use stored dates or fallback to calendar month
    // Handle edge case where start/end are identical or invalid (webhook data issue)
    let periodStart;
    let periodEnd;
    const hasValidPeriod = billing.currentPeriodStart && billing.currentPeriodEnd && billing.currentPeriodEnd.getTime() > billing.currentPeriodStart.getTime();
    if (hasValidPeriod) {
        periodStart = billing.currentPeriodStart;
        periodEnd = billing.currentPeriodEnd;
    } else {
        // Fallback: Use calendar month as billing period
        periodStart = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_1__.startOfMonth)(now);
        periodEnd = (0,_barrel_optimize_names_endOfMonth_startOfMonth_date_fns__WEBPACK_IMPORTED_MODULE_2__.endOfMonth)(now);
        console.warn(`[Billing] Company ${companyId} has invalid period dates, using calendar month fallback`);
    }
    // Count BOQs created this billing period
    const boqsUsedThisPeriod = await computeUsage(periodStart, periodEnd);
    // Determine if company can create BOQ
    let canCreateBoq = false;
    if (isBlocked) {
        canCreateBoq = false;
    } else if (hasActiveSubscription) {
        canCreateBoq = boqLimit === null || boqsUsedThisPeriod < boqLimit;
    }
    return {
        hasActiveSubscription,
        isBlocked,
        planKey: billing.planKey,
        status: billing.status,
        currentPeriodStart: periodStart,
        currentPeriodEnd: periodEnd,
        cancelAtPeriodEnd: billing.cancelAtPeriodEnd,
        boqsUsedThisPeriod,
        boqLimit,
        canCreateBoq,
        hasAdminGrant: false,
        hasTrialGrant: billing.status === "trialing",
        accessOverride: billing?.accessOverride ?? null,
        trialEndsAt: billing.status === "trialing" ? periodEnd : null,
        accessSource: "subscription",
        boqTemplatesLimit: plan?.boqTemplatesLimit ?? null,
        coverTemplatesLimit: plan?.coverTemplatesLimit ?? null,
        logoUploadAllowed: plan?.logoUploadAllowed ?? true,
        sharingAllowed: plan?.sharingAllowed ?? true,
        boqItemsLimit: plan?.boqItemsLimit ?? null,
        watermarkEnabled: plan?.watermarkEnabled ?? false,
        watermarkText: plan?.watermarkText ?? null
    };
}
/**
 * Record a BOQ creation event for quota tracking
 */ async function recordBoqCreation(companyId, boqId) {
    await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.boqCreationEvent.create({
        data: {
            companyId,
            boqId
        }
    });
}
/**
 * Check if user email is a platform admin
 */ function isPlatformAdmin(email) {
    if (!email) return false;
    const adminEmails = process.env.PLATFORM_ADMIN_EMAILS?.split(",").map((e)=>e.trim().toLowerCase()) ?? [];
    return adminEmails.includes(email.toLowerCase());
}
/**
 * Get or create CompanyBilling record
 */ async function getOrCreateBilling(companyId) {
    let billing = await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.findUnique({
        where: {
            companyId
        }
    });
    if (!billing) {
        billing = await _db__WEBPACK_IMPORTED_MODULE_0__.prisma.companyBilling.create({
            data: {
                companyId
            }
        });
    }
    return billing;
}


/***/ }),

/***/ "(rsc)/./lib/db.ts":
/*!*******************!*\
  !*** ./lib/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prisma: () => (/* binding */ prisma)
/* harmony export */ });
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client */ "@prisma/client");
/* harmony import */ var _prisma_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_prisma_client__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _performance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./performance */ "(rsc)/./lib/performance.ts");


const globalForPrisma = globalThis;
/**
 * Connection Pool Configuration for Scale (10k-50k companies)
 * 
 * Recommended DATABASE_URL parameters:
 *   ?connection_limit=20&pool_timeout=30&connect_timeout=10
 * 
 * - connection_limit: Max connections per Prisma instance (default: num_cpus * 2 + 1)
 *   For serverless/edge: use 1-5
 *   For standard servers: use 10-20
 * 
 * - pool_timeout: Seconds to wait for a connection from pool (default: 10)
 * - connect_timeout: Seconds to wait for new connection (default: 5)
 * 
 * For high-scale production:
 * - Consider PgBouncer or Supabase connection pooler
 * - Use transaction pooling mode for short queries
 * - Monitor with: SELECT * FROM pg_stat_activity;
 */ // Create Prisma client with query logging enabled
function createPrismaClient() {
    const isProduction = "development" === "production";
    const client = new _prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({
        log: isProduction ? [
            {
                level: "error",
                emit: "stdout"
            },
            {
                level: "warn",
                emit: "stdout"
            }
        ] : [
            {
                level: "query",
                emit: "event"
            },
            {
                level: "error",
                emit: "stdout"
            },
            {
                level: "warn",
                emit: "stdout"
            }
        ]
    });
    // Add query event listener for slow query detection (dev + prod with ENABLE_QUERY_LOGGING)
    if (!isProduction || process.env.ENABLE_QUERY_LOGGING === "true") {
        client.$on("query", (e)=>{
            const durationMs = e.duration;
            (0,_performance__WEBPACK_IMPORTED_MODULE_1__.logSlowQuery)({
                query: e.query,
                params: e.params,
                durationMs,
                timestamp: new Date(),
                model: extractModelFromQuery(e.query),
                action: extractActionFromQuery(e.query)
            });
        });
    }
    return client;
}
// Extract model name from SQL query for logging
function extractModelFromQuery(query) {
    const fromMatch = query.match(/FROM\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const insertMatch = query.match(/INSERT\s+INTO\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const updateMatch = query.match(/UPDATE\s+["']?public["']?\.?["']?(\w+)["']?/i);
    const deleteMatch = query.match(/DELETE\s+FROM\s+["']?public["']?\.?["']?(\w+)["']?/i);
    return (fromMatch?.[1] || insertMatch?.[1] || updateMatch?.[1] || deleteMatch?.[1] || "unknown").toLowerCase();
}
// Extract action type from SQL query
function extractActionFromQuery(query) {
    const trimmed = query.trim().toUpperCase();
    if (trimmed.startsWith("SELECT")) return "select";
    if (trimmed.startsWith("INSERT")) return "insert";
    if (trimmed.startsWith("UPDATE")) return "update";
    if (trimmed.startsWith("DELETE")) return "delete";
    if (trimmed.startsWith("BEGIN")) return "transaction";
    if (trimmed.startsWith("COMMIT")) return "commit";
    return "other";
}
// Use singleton pattern to prevent connection storms
// In production, each server instance maintains its own pool
// In development, we reuse across hot reloads
const prisma = globalForPrisma.prisma ?? createPrismaClient();
if (true) {
    globalForPrisma.prisma = prisma;
}


/***/ }),

/***/ "(rsc)/./lib/performance.ts":
/*!****************************!*\
  !*** ./lib/performance.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createTimer: () => (/* binding */ createTimer),
/* harmony export */   getRecentMetrics: () => (/* binding */ getRecentMetrics),
/* harmony export */   logError: () => (/* binding */ logError),
/* harmony export */   logRequestMetrics: () => (/* binding */ logRequestMetrics),
/* harmony export */   logSlowQuery: () => (/* binding */ logSlowQuery),
/* harmony export */   withTiming: () => (/* binding */ withTiming)
/* harmony export */ });
/**
 * Performance monitoring and logging utilities
 * For tracking request timing, slow queries, and error tracking
 */ // Threshold for slow query logging (in ms)
const SLOW_QUERY_THRESHOLD = parseInt(process.env.SLOW_QUERY_THRESHOLD || "500", 10);
// In-memory metrics buffer for recent requests (circular buffer)
const MAX_METRICS_BUFFER = 1000;
const requestMetricsBuffer = [];
const slowQueryBuffer = [];
/**
 * Log request metrics
 */ function logRequestMetrics(metrics) {
    // Console log for observability
    const logLevel = metrics.durationMs > 1000 ? "warn" : "info";
    const logData = {
        type: "REQUEST_METRICS",
        ...metrics,
        timestamp: metrics.timestamp.toISOString()
    };
    if (logLevel === "warn") {
        console.warn(`[SLOW_REQUEST] ${metrics.method} ${metrics.endpoint} took ${metrics.durationMs}ms`, JSON.stringify(logData));
    } else if (process.env.VERBOSE_LOGGING === "true") {
        console.log(`[REQUEST] ${metrics.method} ${metrics.endpoint} - ${metrics.durationMs}ms`, JSON.stringify(logData));
    }
    // Add to buffer
    requestMetricsBuffer.push(metrics);
    if (requestMetricsBuffer.length > MAX_METRICS_BUFFER) {
        requestMetricsBuffer.shift();
    }
}
/**
 * Log slow query
 */ function logSlowQuery(metrics) {
    if (metrics.durationMs >= SLOW_QUERY_THRESHOLD) {
        console.warn(`[SLOW_QUERY] ${metrics.model}.${metrics.action} took ${metrics.durationMs}ms`, JSON.stringify({
            type: "SLOW_QUERY",
            ...metrics,
            timestamp: metrics.timestamp.toISOString()
        }));
        slowQueryBuffer.push(metrics);
        if (slowQueryBuffer.length > MAX_METRICS_BUFFER) {
            slowQueryBuffer.shift();
        }
    }
}
/**
 * Log application error with context
 */ function logError(error, context) {
    console.error(`[ERROR] ${context.action || context.endpoint || "Unknown"}`, JSON.stringify({
        type: "APP_ERROR",
        message: error.message,
        stack: error.stack,
        name: error.name,
        ...context,
        timestamp: new Date().toISOString()
    }));
}
/**
 * Timer utility for measuring operation duration
 */ function createTimer() {
    const start = performance.now();
    return {
        elapsed: ()=>Math.round(performance.now() - start)
    };
}
/**
 * Wrap an async function with timing and error tracking
 */ async function withTiming(operation, fn, context) {
    const timer = createTimer();
    try {
        const result = await fn();
        const durationMs = timer.elapsed();
        if (durationMs > 1000) {
            console.warn(`[SLOW_OP] ${operation} took ${durationMs}ms`, context);
        }
        return {
            result,
            durationMs
        };
    } catch (error) {
        logError(error, {
            action: operation,
            ...context
        });
        throw error;
    }
}
/**
 * Get recent metrics for debugging/admin
 */ function getRecentMetrics() {
    return {
        requests: requestMetricsBuffer.slice(-100),
        slowQueries: slowQueryBuffer.slice(-100),
        summary: {
            totalRequests: requestMetricsBuffer.length,
            slowRequests: requestMetricsBuffer.filter((r)=>r.durationMs > 1000).length,
            slowQueries: slowQueryBuffer.length,
            avgRequestTime: requestMetricsBuffer.length > 0 ? Math.round(requestMetricsBuffer.reduce((sum, r)=>sum + r.durationMs, 0) / requestMetricsBuffer.length) : 0
        }
    };
}


/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/next-auth","vendor-chunks/@babel","vendor-chunks/jose","vendor-chunks/openid-client","vendor-chunks/bcryptjs","vendor-chunks/oauth","vendor-chunks/object-hash","vendor-chunks/preact","vendor-chunks/uuid","vendor-chunks/preact-render-to-string","vendor-chunks/oidc-token-hash","vendor-chunks/@panva","vendor-chunks/date-fns"], () => (__webpack_exec__("(rsc)/../../../../opt/hostedapp/node/root/app/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcover-templates%2Froute&page=%2Fapi%2Fcover-templates%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcover-templates%2Froute.ts&appDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fubuntu%2Fmake_estimate%2Fnextjs_space&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();